class GameManager : ZilchComponent
{
  [Dependency] var GameData : GameSharedData;
  [Dependency] var WallManager : GameWallManager;
  
  [Static] var TotalTiles : Integer = 17 * 2 * 4;
  
  [Property] var TurnTime : Real = 15;
  [Property] var TimerTextCogPath : CogPath = CogPath(":/TimeText");
  [Property] var CurrentPlayerTextCogPath : CogPath = CogPath(":/CurrentPlayerText");
  [Property] var CurrentPlayer : WindType = WindType.None;
  
  sends BeginPlayerTurn : ZilchEvent;
  sends ForceEndPlayerTurn : ZilchEvent;
  sends PlayerEndedTurn : ZilchEvent;
  sends RoundBegin : ZilchEvent;
  
  var TurnAction : ActionSet = null;
  var TurnTimer : Real = 0;
  
  function Initialize(init : CogInitializer)
  {
    Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
    Zero.Connect(init, Events.AllObjectsInitialized, this.OnAllObjectsInitialized);
  }

  function OnAllObjectsInitialized(event : CogInitializerEvent)
  {
    // Build the wall and distribute player hands
    Zero.Connect(this.Owner, Events.FinishedBuildingWall, this.OnFinishedBuildingWall);
    this.Owner.InitialGameSetup.CreateWall();
  }
  
  function OnLogicUpdate(event : UpdateEvent)
  {
    // Constantly display the current player and timer (if the game is running)
    this.TurnTimer -= event.Dt;
    if(this.CurrentPlayer == WindType.None)
    {
      var timeText = this.TimerTextCogPath.Cog.SpriteText;
      var playerText = this.CurrentPlayerTextCogPath.Cog.SpriteText;
      timeText.Visible = false;
      playerText.Visible = false;
    }
    else
    {
      var timeText = this.TimerTextCogPath.Cog.SpriteText;
      var playerText = this.CurrentPlayerTextCogPath.Cog.SpriteText;
      timeText.Visible = true;
      playerText.Visible = true;
      timeText.Text = String.FormatC("Time: %.1f", this.TurnTimer);
      playerText.Text = "Player: `this.CurrentPlayer`";
    }
  }

  function OnFinishedBuildingWall(event : ZilchEvent)
  {
    // Start with east
    this.CurrentPlayer = WindType.East;
    
    // Notify everyone that the round is beginning (starts ai)
    this.Space.DispatchEvent(Events.RoundBegin, ZilchEvent());
    // Start player1's turn
    this.BeginPlayerTurn();
  }
  
  function GetCurrentPlayerIndex() : Integer
  {
    return this.CurrentPlayer as Integer;
  }
  
  function GetCurrentPlayerCog() : Cog
  {
    return this.GameData.PlayerCogs[this.GetCurrentPlayerIndex()];
  }
  
  function BeginPlayerTurn()
  {
    var currentPlayer = this.GetCurrentPlayerCog();
    var currentPlayerIndex = this.GetCurrentPlayerIndex();
    // Listen to the current player trying to end their turn
    Zero.Connect(currentPlayer, Events.PlayerFinishedTurn, this.OnPlayerFinishedTurn);
    
    // Animate the tile to the player's hand
    var seq = Actions.Sequence(this.Owner.Actions);
    this.WallManager.AnimateCurrentTileToPlayerHand( currentPlayerIndex, seq);
    Actions.Call(seq, this.PlayerHasBeenDealtTile);
  }
  
  function PlayerHasBeenDealtTile()
  {
    // Tell the player to begin their turn
    var currentPlayer = this.GetCurrentPlayerCog();
    currentPlayer.DispatchEvent(Events.BeginPlayerTurn, ZilchEvent());
    // Queue up actions to track when a player is out of time
    this.QueueTurnActions();
  }
  
  function StartNextPlayerTurn()
  {
    // Update the current player
    var playerIndex = this.CurrentPlayer as Integer;
    playerIndex = (playerIndex + 1) % 4;
    this.CurrentPlayer = playerIndex as WindType;
    // Start the next player's turn
    this.BeginPlayerTurn();
  }

  function OnPlayerFinishedTurn(event : ZilchEvent)
  {
    // The player manually finished their turn (didn't run out of time).
    // First, cancel the current turn actions so we don't trigger "out of time" logic
    this.TurnAction.Cancel();
    // Stop listening for the current player's turn finish
    var currentPlayer = this.GetCurrentPlayerCog();
    Zero.Disconnect(currentPlayer, Events.PlayerFinishedTurn, this);
    // Start the next player turn
    this.StartNextPlayerTurn();
  }
  
  function OutOfTurnTime()
  {
    // Tell the player that they have to end their turn now
    var currentPlayer = this.GetCurrentPlayerCog();
    currentPlayer.DispatchEvent(Events.ForceEndPlayerTurn, ZilchEvent());
    
    // Start the next player's turn
    this.StartNextPlayerTurn();
  }
  
  function QueueTurnActions()
  {
    // Queue up actions to wait a certain amount of time and then
    // force a turn end (maybe change to logic update?)
    this.TurnAction = Action.Sequence(this.Owner.Actions);
    Action.Delay(this.TurnAction, this.TurnTime);
    Action.Call(this.TurnAction, this.OutOfTurnTime);
    
    // Keep track of the action set so we can cancel these
    // actions when the player manually finishes their turn
    this.TurnTimer = this.TurnTime;
  }
}

